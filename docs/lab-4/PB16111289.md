<h1>report for lab-4</h1>
<h2>PB16111289 张家坤</h2>

<h2>一.实验结果</h2>

最终得分为<br>
RESULT: [  104  / 100 ]<br>

```
----------------------------------------------------------------------------------------
Case: code1
----------------------------------------------------------------------------------------
Case: code2
----------------------------------------------------------------------------------------
Case: code3
----------------------------------------------------------------------------------------
Case: code4
----------------------------------------------------------------------------------------
Case: code5
----------------------------------------------------------------------------------------
Case: code10
----------------------------------------------------------------------------------------
Case: code6
----------------------------------------------------------------------------------------
Case: code7
----------------------------------------------------------------------------------------
Case: code8
----------------------------------------------------------------------------------------
Case: code9
----------------------------------------------------------------------------------------
Case: code11
----------------------------------------------------------------------------------------
Case: code12
----------------------------------------------------------------------------------------
Case: code13
1c1
< 720
---
> 1
----------------------------------------------------------------------------------------
Case: code14
1c1
< 13
---
> 6
----------------------------------------------------------------------------------------
Case: code15
----------------------------------------------------------------------------------------
Case: code16
----------------------------------------------------------------------------------------
Case: code17
----------------------------------------------------------------------------------------
Case: code18
----------------------------------------------------------------------------------------
Case: code19
----------------------------------------------------------------------------------------
Case: code20
----------------------------------------------------------------------------------------
Case: code21
1c1
< 13
---
> ERROR: Illegal stack access from instruction 'LD 4' at line 29.
----------------------------------------------------------------------------------------
Case: code22
----------------------------------------------------------------------------------------
Case: code23
1d0
< 6
----------------------------------------------------------------------------------------
Case: code24
1d0
< 13
----------------------------------------------------------------------------------------
Case: code25
----------------------------------------------------------------------------------------
Case: code26
1c1
< 75
---
> 1
----------------------------------------------------------------------------------------
Case: code27
1c1
< 12
---
> ERROR: Timeout.

```

<h2>二、我的工作</h2>

除了基础的运算外，我的工作主要集中在条件指令的短路运算、利用栈跳转方式的实现过程调用以及全局变量和局部变量的简单区分，下面简要讲一下这几个方面。

<h3>1.过程调用</h3>
*非重要的代码用省略号以及注释的形式说明<br
关于过程调用，最初的形式是在生成汇编的时候直接生成静态地址，这样做其实与真正的程序相违背，也很难实现递归调用，为了解决这个问题后修改为利用栈的方式来跳转，基本思想并不繁琐，主要是在调用的时候，将下条指令的地址压入栈，过程返回的时候直接利用JMP指令来跳转到栈顶的返回地址即可。<br>
下面是调用时的代码生成过程：<br>
```
    ······
    else if(lex->last_token_type==TOKEN_CALL)
    {
	    PL0Lex_get_token_valid(S,lex);
	    int IdTablePosition=LookupTable(lex->last_id,lex);
	    if(lex->last_token_type!=TOKEN_IDENTIFIER)
	        printf("\n★  There must be an id following 'call'\n");
	    else {
            if(IdTablePosition==-1)
            {
                printf("\n★  Undeclared identifier.\n");
            }
            else if (token_table[IdTablePosition].kind == ID_PROCEDURE)//跳转到procedure指示的地址
            {
				Gen(PUT,0, code_index+2 ,AdressOrNum);//地址压栈
                Gen(JMP,0, token_table[IdTablePosition].procedureaddress,AdressOrNum);//跳转到过程
                code_index_call = code_index;//记录跳转之后的第一条指令地址
				code[token_table[IdTablePosition].procedureendaddress].address=code_index_call;
            }
            else {
                printf("\n★  A constant or variable can not be called.\n");
            }
            PL0Lex_get_token_valid(S, lex);
        }
	}
    ······
```
下面是过程的处理的部分代码，涉及到跳转的其实就是一条无操作数的JMP指令：
```
else if(lex->last_token_type==TOKEN_PROCEDURE)//分析过程，先跳转到main函数
		{
			······							
			if(lex->last_token_type==TOKEN_IDENTIFIER)
			{
				······
				if(!return_flag)//没有return时结束后跳转
					Gen(JMP,0,0,NoAdressOrNum);
                    //Gen(JMP,0,0,AdressOrNum);//at the end of the procedure we should jmp back to the position where we call it.
				if(lex->last_token_type!=TOKEN_SEMICOLON)	
					printf("\n★  missing ';'\n");
				PL0Lex_get_token_valid(S,lex);
			}
			······
		}
```

<h3>2.短路运算</h3>
短路运算的基本想法就是在原有的条件分析上加以修改，使之在遇到每个||或者&&运算符的时候，进行判断是否跳转，其中||判断左侧条件为1则跳转到正确代码，&&左侧条件为假则跳转到错误代码区，加入相应逻辑后的condition函数如下：<br>
```
void condition(PL0Lex *lex){
	int TempType;
	CONDITION(lex);
	while(lex->last_token_type == TOKEN_AND||lex->last_token_type == TOKEN_OR){

		if(TempType==TOKEN_AND){//短路
			Gen(NOT,0,0,NoAdressOrNum);
			code_index_and = code_index;
			Gen(JPC,0,0,AdressOrNum);
		}
			
		else{
			code_index_or = code_index;
			Gen(JPC,0,0,AdressOrNum);
		}
		TempType = lex->last_token_type;
		PL0Lex_get_token_valid(S,lex);
		CONDITION(lex);
		if(TempType==TOKEN_AND)
			Gen(AND,0,0,NoAdressOrNum);
		else
			Gen(OR,0,0,NoAdressOrNum);
	}
}
```

<h3>3.局部变量</h3>
这里实现的同名的局部变量和全局变量的区分使用的是较为简单的规则，对编程有一定的要求。实现原理是这样：给变量增加属性值local，在构造变量表时，如果某个变量是在过程中声明的，则将local置为1，否则为0，二者视为不同的变量加入变量表，并且分配不同的地址。这写操作在procedure分析的过程中完成，代码较为简单，这里略去。<br>

同样的，在过程内或者过程外引用这个变量时，查找变量表时判断相应变量的local域，来决定变量的地址。下面是修改后的表查找函数（其中local_ornot是一个全局变量，标记当前实在主函数还是被调用过程中，对local域赋值或者变量表查找都会利用到）：<br>

```
int LookupTable(char* c,PL0Lex *lex){					//see if the id is already defined
	int i;
	int j = -1;
	for(i=0;i<table_index;i++)
		if(strcmp(c,token_table[i].name)==0){
			if(token_table[i].local ==local_ornot)
				return i;
			else{
				j = i;
			}
		}		
				
	return j;
}

```

<h2>4.过程中遇到的问题<h2>
<h3>问题.1——如何具体落实代码翻译</h3>
***原因：***未能很好地理解代码生成的本质，拿到实验有些感到无从下手。<br>
***解决方案：***经过几次小组讨论分析，我们发现代码生成是建立在语法分析的基础之上的，只需要在语法分析代码适当的位置嵌入生成代码的语句即可,本质就是将源代码翻译成相应的汇编语言并且生成相应的文件。


<h3>问题.2——利用栈实现过程调用的时候，跳转出错</h3>
***原因：***这里的原因是很多时候栈没有进行合适的操作，例如过程中含有INT指令，这个指令是不出栈的，所以导致跳转错误<br>
***解决方案：***想办法实现出栈，这里定义了一个指令序列如下起到出栈的作用<br>

```
PUT 0
MUL
ADD
```
对应代码为:<br>
```
Gen(PUT,0,0,AdressOrNum);
Gen(MUL,0,0,NoAdressOrNum);
Gen(ADD,0,0,NoAdressOrNum);
```
更进一步地，这里存在一个问题，栈只有一个元素的时候，这个指令序列会导致错误，为了避免这个错误，所以在每个程序的最开始阶段加入一个PUT 0指令来初始化栈，看起来是相当麻烦，不过在没有pop指令的情况下只能如此勉强一下。<br>


<h3>三、实验总结、感悟</h3>
为期一学期的编译实验结束了，在最终的实验中，和队友讨论协作完成了代码翻译的部分，最终使之成为一个勉强可用的pl0编译器，虽然很多功能不完备或者尚有欠缺，但是的确更为清晰地认识了代码生成地过程，并且将四次实验连贯起来，了解了一个编译器地大致层次，收获甚多。
同时，通过这学期地实验，另一个收获是学会更熟练地利用git进行代码管理和团队协作，确实为学习工作中最为实用的技能之一。



