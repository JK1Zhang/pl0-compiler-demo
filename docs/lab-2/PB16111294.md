# 编译原理语法分析实验报告  
## 实验目的 
&emsp;理解pl0语法图，对给定的程序进行递归下降分析，输出分析时的语法树（栈），并完成错误恢复。   
## 实验过程 
1.大致实现过程  
&emsp;整个实验总体上分为两个问题，一是按照语法图对给定的程序进行分析，另一个就是在分析的过程中输出栈变化中的栈。分析程序的过程就是按照给定的pl0语法图进行即可，变化栈的输出则需要根据语法图写出相应的LL1文法，并在每次读入标识符的时候按照教材上的规则对栈进行操作，同时完成错误恢复工作，错误恢复的原则也是教材上的。  
2.具体实现  
&emsp;由于本次实验代码量比较大，在此便不贴出整个程序的实现代码，仅对各函数的功能进行解释。  
- 分析程序的主要函数如下：
> program(PL0Lex *lex): 整个程序的分析入口  
> program_block(PL0Lex *lex): 程序体的分析入口  
> statement(PL0Lex * lex): 语句的分析入口   
> statementseq(PL0Lex * lex): 语句序列的分析入口    
> condition(PL0Lex * lex): 条件的分析入口   
> expression(PL0Lex * lex): 表达式的分析入口    
> term(PL0Lex * lex): 项的分析入口  
> factor(PL0Lex * lex): 因子的分析入口      

&emsp;&emsp;在程序运行过程中，除statement()以外，其他函数的第一个token都是由调用该函数的上一级函数提供，并且每个函数在结束时都会读入下一个token（program除外）以便之后的程序使用。  

- 栈输出操作的主要函数：    
> Shift(Stack *S,char *c): 按照教材的规则将相应的产生式压入栈   
> Transfer(PL0Lex *lex,char *result): 将读入的token转换为产生式的对应形式，以便进行入栈操作     
> MatchParser(char *Stop, char *c, char result[Max_Parser_Len][MAX_ID_LEN]): 根据栈顶的非终结符和读入的token确定对应的产生式，result存放的即为对应的产生式  
> Synch(char *Stop, char *str): 判断str是否为栈顶非终结符的同步符号集，用于错误恢复     
> First(char *Stop, char *str): 判断str是否为栈顶非终结符的FIRST集合，用于确定产生式    

&emsp;&emsp;不知何种原因，程序无法包含C++的头文件，故栈和栈操作均为自己实现，具体实现在stack.c中，由于实现较为简单，在此不做说明。  
3.主要问题  
&emsp;本次实验遇到的主要问题如下：  
&emsp;(1)在分析程序的过程中，一开始对何时读入标识符不清楚，导致经常多读或者少读符号，整个程序运行出错，在通过GDB调试并理清思路后确定了读入符号的位置，程序终于能够成功运行。    
&emsp;(2)在实现输出分析栈的过程中，刚开始不知从何下手，甚至想要直接使用printf来实现，但是经过分析该种方法完全不可行，因为分析程序的过程存在递归调用，且该种方法完全无法用于错误恢复，于是最终还是使用了自己实现的栈来模拟整个程序的分析过程。   
&emsp;(3)同样在输出分析栈的实现过程中，由于使用的LL1文法，所以需要构造每个非终结符的FIRST和FOLLOW集合，同时因为错误恢复的需要还要构造同步记号集合，在一开始构造的过程中有几个非终结符的集合构造出错导致程序发生死循环的情况，之后通过GDB调试找到出错的地方，修改正确后程序正常运行。    
# 实验总结  
&emsp;通过本次实验，真正完成了一个可以正确分析程序的文法，同时对LL1文法加深了理解，对文法的错误恢复也有了新的认识。在本次实验我的工作如下：总体分析程序框架的完成，入栈操作的完成。